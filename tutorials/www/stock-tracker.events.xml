<?xml version="1.0" encoding="UTF-8"?>
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License,
Version 2.0 (the "License"); you may not use this file except in
compliance with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<document id="stock-tracker.events">
    <properties>
        <title>Event Handling</title>
    </properties>

    <body>
        <p>
            While WTKX is used to declare the <i>structure</i> of an application, the application's
            <i>behavior</i> is defined in code (either Java or a JVM-compatible scripting language).
            Most of this logic is executed in response to an "event" triggered by some external
            source, such as user input or the completion of an asynchronous operation running in a
            background thread.
        </p>

        <p>
            In general, a Pivot application will load its user interface and wire up event handlers
            in the <tt>startup()</tt> method of the main application class. This method, along with
            the <tt>shutdown()</tt>, <tt>suspend()</tt>, and <tt>resume()</tt> methods, is defined
            by the <tt>Application</tt> interface, which all Pivot applications must implement.
        </p>

        <h2>Loading the UI</h2>

        <p>
            The <tt>Application</tt> interface in the Stock Tracker demo is implemented by the
            <tt>StockTracker</tt> class. The code in this file is referred to throughout the course
            of this section. A snippet of code from <tt>StockTracker</tt>'s <tt>startup()</tt>
            method is shown below:
        </p>

        <source type="java">
            <![CDATA[
            // Set the locale
            String language = properties.get(LANGUAGE_PROPERTY_NAME);
            if (language != null) {
                Locale.setDefault(new Locale(language));
            }

            // Load and bind to the WTKX source
            Resources resources = new Resources(this);
            WTKXSerializer wtkxSerializer = new WTKXSerializer(resources);
            window = (Window)wtkxSerializer.readObject(this, "stocktracker.wtkx");
            wtkxSerializer.bind(this, StockTracker.class);
            ]]>
        </source>

        <p>
            This code does the following:
        </p>

        <ul>
            <li>
                <p>
                    Retrieves the "langauge" argument that was provided to the application context
                    when it was created - for desktop applications, this is a command-line
                    argument; in the browser, it is either passed via an applet parameter
                </p>
            </li>
            <li>
                <p>
                    Sets the default locale to an instance corresponding to the language
                    argument
                </p>
            </li>
            <li>
                <p>
                    Loads the application resources
                </p>
            </li>
            <li>
                <p>
                    Creates an instance of <tt>WTKXSerializer</tt> and loads the WTKX source
                </p>
            </li>
        </ul>

        <p>
            Finally, the code calls the <tt>bind()</tt> method on the serializer, which associates
            annotated member variables with corresponding IDs in the WTKX file:
        </p>

        <source type="java">
            <![CDATA[
            @WTKX private TableView stocksTableView;
            @WTKX private TextInput symbolTextInput;
            @WTKX private Button addSymbolButton;
            @WTKX private Button removeSymbolsButton;
            ...
            ]]>
        </source>

        <p>
            These annotations eliminate much of the boilerplate code required when loading WTKX
            contents manually via an instance of <tt>WTKXSerializer</tt>. However, since they rely
            on reflection code that may need to set private member variables, they can generally
            only be used by trusted code, such as a locally installed application or a signed
            applet or Web Start application.
        </p>

        <h2>Adding Event Listeners</h2>

        <p>
            At this point, the entire UI has been created, but it is not yet visible. Even if it
            was, it wouldn't do much, since no event handlers have been added. The next thing
            <tt>startup()</tt> does is add a number of event handlers:
        </p>

        <source type="java">
            <![CDATA[
            stocksTableView.getTableViewSelectionListeners().add(new TableViewSelectionListener.Adapter() {
                public void selectedRangesChanged(TableView tableView, Sequence&lt;Span&gt; previousSelectedRanges) {
                    refreshDetail();
                }
            });
            ...

            addSymbolButton.getButtonPressListeners().add(new ButtonPressListener() {
                public void buttonPressed(Button button) {
                    addSymbol();
                }
            });
            ...
            ]]>
        </source>

        <p>
            A caller signals its interest in a particular event by implementing an interface that
            defines an event handler method and adding itself as an event lister on the event
            source. In the example above, two event handlers are created: a selection change
            listener on the stock quote table view and a button press listener on the "add symbol"
            button. Some listener interfaces, such as those shown here, define only a single event
            handler method, but others define more than one and serve as a grouping of related
            events. Interfaces with multiple handler methods generally define an inner Adapter
            class that can be used to simplify subclassing, as shown above.
        </p>

        <p>
            Note that, though these handlers are implemented as anonymous inner classes, this is
            not required - any class that implements the appropriate listener interface can
            register as a listener. It is also possible to define listeners in script within the
            WTKX file itself; this is discussed in more detail in the
            <a href="scripting.html">Scripting</a> section.
        </p>

        <h2>Displaying the Content</h2>

        <p>
            Finally, the window loaded from the WTKX files is opened, making the application
            visible and allowing the user to begin interacting with it (note that the window's
            "maximized" property is set to "true" in the WTKX file so that, when opened, the
            window will be sized to fit the entire display area):
        </p>

        <source type="java">
            <![CDATA[
            window.open();

            refreshTable();

            ApplicationContext.setInterval(new Runnable() {
                public void run() {
                    refreshTable();
                }
            }, REFRESH_INTERVAL);

            symbolTextInput.requestFocus();
            ]]>
        </source>

        <p>
            The code then calls <tt>refreshTable()</tt> to load the stock quote data and sets a
            timer interval to reload the data every 15 seconds. Finally, it sets the focus to the
            symbol text input, so a user can easily add a new stock to track.
        </p>
    </body>
</document>
